[{"title":"使用Autoprefixer实现CSS浏览器前缀自动化","path":"/2024/11/04/使用Autoprefixer实现CSS浏览器前缀自动化 /","content":"每次写css都需要手动加前缀，烦的不得了。而Autoprefixer作为PostCSS生态核心插件，能自动为CSS属性添加浏览器厂商前缀（如-webkit-、-moz-）。正好能解决这个问题 1. 安装依赖通过npm安装核心组件： 1npm install postcss-loader autoprefixer postcss --save-dev 2.在webpack中添加配置12345678910111213141516171819202122// webpack.config.jsmodule.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#123; loader: &#x27;postcss-loader&#x27;, options: &#123; postcssOptions: &#123; plugins: [require(&#x27;autoprefixer&#x27;)] &#125; &#125; &#125; ] &#125; ] &#125;&#125;; 3.定义目标浏览器在package.json中配置： 123456&quot;browserslist&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 Chrome versions&quot;, &quot;not IE 11&quot;] 最终结果1234.box &#123; transform: scale(0.5); user-select: none;&#125; 会自动编译成 1234567.box &#123; -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-user-select: none; -moz-user-select: none; user-select: none;&#125; 感谢观看，如果对你有帮助可以关注本站，龙小亦在此谢过了","tags":["css","js","html"],"categories":["CSS"]},{"title":"解决不同浏览器滚动条样式的最终方案-手写滚动条","path":"/2024/05/04/解决不同浏览器滚动条样式的最终方案-手写滚动条/","content":"前端经常遇到各种浏览器的兼容问题，无论是浏览器api层面的还是样式层面的，都非常让人头痛。尤其是当产品提出“为什么滚动条在各个浏览器上面的样式不一样，能不能统一下”时，我彻底悟了，与其无休止的调各个浏览器滚动条的样式问题，为什么我不自己写一个滚动条呢，于是这篇文章就出来了。 手写滚动条样式滚动条样式其实很简单，不过在写滚动条样式的时候我们需要将浏览器自带的滚动条隐藏掉 ./style.css1234567891011*&#123; /* 隐藏滚动条 */ &lt;!-- 火狐 --&gt; scrollbar-width: none; &lt;!-- E 与微软浏览器 --&gt; -ms-overflow-style: none;&#125;&lt;!-- chrome --&gt;*::-webkit-scrollbar &#123; display: none;&#125; 滚动条样式(这里我是用div来模拟滚动条的) ./xxx.vue12345678910111213&lt;template&gt; &lt;!-- 滚动容器 --&gt; &lt;div class=&quot;scroll_container&quot; @scroll=&quot;onScroll&quot; :style=&quot;&#123; transform: `translate(0px, $&#123;scrollBarTop&#125;px)` &#125;&quot;&gt; &lt;!-- 滚动容器内容区域 --&gt; &lt;div class=&quot;scroll_view&quot;&gt; // 滚动区域的内容 &lt;/div&gt; &lt;!-- 滚动条 --&gt; &lt;div class=&quot;scroll_bar&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; ./xxx.css123456789101112.scroll_bar &#123; display: block; position: absolute; top: 0; z-index: 999; width: 6px; right: 0; border-radius: 3px; background-color: rgba(0, 0, 0, 0.3); transition: opacity 0.1s ease-in-out; hieght: 120px;&#125; 这样一个滚动条的样式就出现在我们屏幕的右边了 实现滚动条滚动因为我用的是vue3，所以这部分都是按照vue3的方式来写。 实现思路怎么让屏幕滑动到最低端时滚动条也一起滑动到最低端，这里我说一下大概的思路。我这里是用的是 css 中的 transform 来实现的。首先我们得先知道滚动容器可以滚动多远(滚动最大距离)，这点我们可以通过滚动容器内容区域的高度减去滚动容器本身的高度，这里需要注意的是当滚动容器中的内容不可滚动时的情况(滚动容器内容区域的高度小于滚动容器本身的高度)得到了滚动最大距离之后就可以计算滚动条应该位移的距离了，我们通过监听scroll事件得到当前滚动的距离，用当前滚动距离/最大滚动距离可以得到当前滚动距离的百分比，然后用这个百分比*(滚动容器内容区域的高度 - 滚动条本身的高度)就得到了滚动条应该滚动的距离了。大致思路就是这样的，听起来很啰嗦，直接看代码吧！ ./xxx.vue12345678910111213141516171819// js部分// 滚动容器const scrollREF = ref&lt;HTMLDivElement&gt;();// 滚动容器内容区域const scrollContentREF = ref&lt;HTMLDivElement&gt;();// 滚动条应该滚动的距离const scrollBarTop = ref(0);const onScroll = () =&gt; &#123; if (scrollREF.value &amp;&amp; scrollContentREF.value) &#123; // 先计算可以滑动多远 const scrollRange = scrollContentREF.value.clientHeight &gt; scrollREF.value.clientHeight ? scrollContentREF.value.clientHeight - scrollREF.value.clientHeight : 0; scrollRange &gt; 0 &amp;&amp; (scrollBarTop.value = (scrollREF.value.scrollTop / scrollRange) * (scrollContentREF.value.clientHeight - scrollHeight.value)); &#125;&#125;; 其实到这里滚动条基本功能就已经实现了，还有细节可以优化 细节优化滚动条高度问题存在的问题其实上面已经属于一个勉强能用的状态，但是有一个很致命的问题–滚动条的高度是固定的。浏览器自带的滚动条会根据滚动内容区域的高度进行变化(内容多时: 滚动条变矮, 内容少时，滚动条变高)，那样更符合人类的直觉。滚动条固定还有一个破坏体验感的就是–当内容比较少时滚动条又太矮了，滚动条的滚动速度就会太快；当内容比较多时滚动条又比较高时，很察觉滚动条的滚动。 实现思路其实有很多解决方法，只要是大概符合反比例函数的模型的其实都是可以的(当滑动区域越小时，滚动条高度越高；当滑动区域越大时，滚动条高度越低)。我的解决方法是滚动容器高度/滚动内容区域高度*滚动容器高度 ./xxx.vue1234567891011// 滚动条应该滚动的距离const scrollHeight = ref(0);if (scrollContentREF.value &amp;&amp; scrollREF.value) &#123; // 我这里进行了取整，因为后面需要减去滚动条的高度，尽量避免高度出现小数 // 关于这里需不需要处理 (滚动容器高度/滚动内容区域高度 ) &gt; 1 的情况， // 我认为不需要，因为大于1时就证明滚动容器内容区域无法滚动，无法滚动自然就无法触发scroll回调 scrollHeight.value = Math.trunc( (scrollREF.value.clientHeight / scrollContentREF.value.clientHeight) * scrollREF.value.clientHeight ); &#125; 模板代码中需要将scrollHeight加进去 如果你的滚动区域是静态数据(页面加载成功滚动区域的数据就不会变化)可以直接将面的那段代码写入生命周期中(onMounted)。 如果你滚动区域是动态变化的数据(可以滚动新增内容的那种)你可以将上面的代码封装成一个函数，在每次新数据加载好了之后调用一次。 其他可以优化的地方 滚动条在非滚动时不可见 ./xxx.vue123456789101112131415161718192021222324252627282930313233// 我这里是通过透明度实现const scrollOpacity = ref(0);let scrollDisplayTimer: Timer = null;// js部分// 滚动容器const scrollREF = ref&lt;HTMLDivElement&gt;();// 滚动容器内容区域const scrollContentREF = ref&lt;HTMLDivElement&gt;();// 滚动条应该滚动的距离const scrollBarTop = ref(0);const scrollOpacity = ref(0);const onScroll = () =&gt; &#123; if (scrollREF.value &amp;&amp; scrollContentREF.value) &#123; // 先计算可以滑动多远 const scrollRange = scrollContentREF.value.clientHeight &gt; scrollREF.value.clientHeight ? scrollContentREF.value.clientHeight - scrollREF.value.clientHeight : 0; scrollRange &gt; 0 &amp;&amp; (scrollBarTop.value = (scrollREF.value.scrollTop / scrollRange) * (scrollContentREF.value.clientHeight - scrollHeight.value)); // &lt;!-- 控制滚动条是否显示 start --&gt; scrollOpacity.value = 1; if (scrollDisplayTimer) &#123; clearTimeout(scrollDisplayTimer); &#125; scrollDisplayTimer = setTimeout(() =&gt; &#123; scrollOpacity.value = 0; &#125;, 1500); // &lt;!-- 控制滚动条是否显示 end --&gt; &#125;&#125;; 模板代码中需要将scrollOpacity加进去 最终代码 模板部分 ./xxx.vue1234567891011121314151617&lt;template&gt; &lt;!-- 滚动容器 --&gt; &lt;div class=&quot;scroll_container&quot; @scroll=&quot;onScroll&quot; :style=&quot;&#123; transform: `translate(0px, $&#123;scrollBarTop&#125;px)`, height: `$&#123;scrollHeight&#125;px`, opacity: scrollOpacity, &#125;&quot;&gt; &lt;!-- 滚动容器内容区域 --&gt; &lt;div class=&quot;scroll_view&quot;&gt; // 滚动区域的内容 &lt;/div&gt; &lt;!-- 滚动条 --&gt; &lt;div class=&quot;scroll_bar&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; js部分 ./xxx.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 滚动容器const scrollREF = ref&lt;HTMLDivElement&gt;();// 滚动容器内容区域const scrollContentREF = ref&lt;HTMLDivElement&gt;();// 滚动条应该滚动的距离const scrollBarTop = ref(0);// 滚动条透明度const scrollOpacity = ref(0);// 滚动条高度const scrollHeight = ref(0);// 计算滚动条高度const countscrollHeight = () =&gt; &#123; if (scrollContentREF.value &amp;&amp; scrollREF.value) &#123; // 我这里进行了取整，因为后面需要减去滚动条的高度，尽量避免高度出现小数 scrollHeight.value = Math.trunc( (scrollREF.value.clientHeight / scrollContentREF.value.clientHeight) * scrollREF.value.clientHeight ); &#125;&#125;//滑动监听事件const onScroll = () =&gt; &#123; if (scrollREF.value &amp;&amp; scrollContentREF.value) &#123; // 先计算可以滑动多远 const scrollRange = scrollContentREF.value.clientHeight &gt; scrollREF.value.clientHeight ? scrollContentREF.value.clientHeight - scrollREF.value.clientHeight : 0; scrollRange &gt; 0 &amp;&amp; (scrollBarTop.value = (scrollREF.value.scrollTop / scrollRange) * (scrollContentREF.value.clientHeight - scrollHeight.value)); // &lt;!-- 控制滚动条是否显示 start --&gt; scrollOpacity.value = 1; if (scrollDisplayTimer) &#123; clearTimeout(scrollDisplayTimer); &#125; scrollDisplayTimer = setTimeout(() =&gt; &#123; scrollOpacity.value = 0; &#125;, 1500); // &lt;!-- 控制滚动条是否显示 end --&gt; &#125;&#125;;onMounted(() =&gt; &#123; countscrollHeight();&#125;); css部分 ./xxx.css12345678910111213141516171819202122*&#123; /* 隐藏滚动条 */ &lt;!-- 火狐 --&gt; scrollbar-width: none; &lt;!-- E 与微软浏览器 --&gt; -ms-overflow-style: none;&#125;&lt;!-- chrome --&gt;*::-webkit-scrollbar &#123; display: none;&#125;.scroll_bar &#123; display: block; position: absolute; top: 0; z-index: 999; width: 6px; right: 0; border-radius: 3px; background-color: rgba(0, 0, 0, 0.3); transition: opacity 0.1s ease-in-out;&#125; 感谢观看，如果对你有帮助可以关注本站，龙小亦在此谢过了","tags":["css","js","vue","html"],"categories":["vue"]},{"title":"hexo Stellar主题通过Vercel部署waline","path":"/2024/04/28/hexo-Stellar主题通过Vercel部署waline/","content":"一直想给自己的博客添加评论系统，拖到了现在终于加上了。本文是傻瓜式教程，如果嫌麻烦可以直接参考XAOXUU的，地址在下方。本文使用的是waline评论插件，通过Vercel部署。 https://xaoxuu.com/wiki/stellar/comments/#Walinehttps://xaoxuu.com/wiki/stellar/comments/#Waline LeanCloud(数据库)注册 登录 或 注册 LeanCloud 国际版 并进入 控制台 在LeanCloud中 创建应用(选择免费开发版即可) 进入应用，选择左下角的 设置 &gt; 应用 Key。你可以看到你的 APP ID,APP Key 和 Master Key。请记录它们，以便后续使用。 Vercel 部署 登录 或 注册 Vercel，并绑定自己的github账号。 输入一个你喜欢的 Vercel 项目名称并点击 Create 继续: 此时 Vercel 会基于 Waline 模板帮助你新建并初始化仓库，仓库名为你之前输入的项目名。(对应的github上也会有这个仓库-私密仓库) 一两分钟后，满屏的烟花会庆祝你部署成功。此时点击 Go to Dashboard 可以跳转到应用的控制台。 点击顶部的 Settings - Environment Variables 进入环境变量配置页，并配置三个环境变量 LEAN_ID, LEAN_KEY 和 LEAN_MASTER_KEY 。它们的值分别对应上一步在 LeanCloud 中获得的 APP ID, APP KEY, Master Key。 环境变量配置完成之后点击顶部的 Deployments 点击顶部最新的一次部署右侧的 Redeploy 按钮进行重新部署。该步骤是为了让刚才设置的环境变量生效。 此时会跳转到 Overview 界面开始部署，等待片刻后 STATUS 会变成 Ready。此时请点击 Visit ，即可跳转到部署好的网站地址，此地址即为你的服务端地址。 域名 域名绑定(可选)，就算不绑定 Vercel 也会分配一个域名。 查看默认域名域名绑定 进入Vercel App 管理 进入对应App管理页面。 App信息卡片有个Deployment信息，这就是分配的域名。 在域名服务器商处添加新的 CNAME 解析记录 Type Name Value CNAME example cname.vercel-dns.com 在App 管理页面点击顶部的 Settings - Domains 进入域名配置页。 输入需要绑定的域名并点击 Add。 4. 等待生效，你可以通过自己的域名来访问了🎉 评论管理页面 如果是绑定了自己的域名评论系统：域名评论管理：域名&#x2F;ui 如果没绑定自己的域名评论系统：分配的域名评论管理：分配的域名&#x2F;ui 评论管理员注册:请访问 域名/ui/register 进行注册。首个注册的人会被设定成管理员。 stellar 添加waline插件blog/_config.stellar.yml1234567891011121314151617181920212223242526comments: service: waline waline: js: https://unpkg.com/@waline/client@v2/dist/waline.js css: https://unpkg.com/@waline/client@v2/dist/waline.css # Waline server address url, you should set this to your own link serverURL: https://xxx # waline域名 地址 # If false, comment count will only be displayed in post page, not in home page commentCount: true # Pageviews count, Note: You should not enable both `waline.pageview` and `leancloud_visitors`. pageview: false # Custom locales locale: placeholder: # 输入框内提示文字 # Custom emoji emoji: - https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs # - https://unpkg.com/@waline/emojis@1.1.0/weibo # - https://unpkg.com/@waline/emojis@1.1.0/alus # - https://unpkg.com/@waline/emojis@1.1.0/bilibili # - https://unpkg.com/@waline/emojis@1.1.0/qq # - https://unpkg.com/@waline/emojis@1.1.0/tieba # - https://unpkg.com/@waline/emojis@1.1.0/tw-emoji # - https://unpkg.com/@waline/emojis@1.1.0/bmoji 感谢观看，如果对你有帮助可以关注本站，龙小亦在此谢过了","tags":["hexo"],"categories":["hexo"]},{"title":"flutter AnimationController动画","path":"/2024/03/15/flutter-AnimationController动画/","content":"碰到的问题 最近在搞Flutter，碰到了一个动画需求，【点击按钮组件从左边滑出，再次点击后从左边消失】 使用了SizeTransition组件+AnimationController实现动画的播放和控制 动画代码123456789101112131415// 动画控制器AnimationController( vsync: this, duration: const Duration(milliseconds: 800), // 动画时长 ..repeat(); // 动画循环)...// 动画组件SizeTransition( sizeFactor: _animationController, // 动画控制器 axis: Axis.horizontal, // 动画方向 axisAlignment: 0.0, // 基础位移 child: const Text(&quot;动画&quot;),), 如果不希望动画一直循环，在动画控制器一定不要加上..repeat() 加上按钮控制动画播放1234567891011121314151617181920212223// 定义一个变量记录动画目前的状态_animationIsPlayer = false;...// 按钮控制动画IconButton( splashColor: Colors.transparent, highlightColor: Colors.transparent, hoverColor: Colors.transparent, onPressed: () &#123; setState(() &#123; _animationIsPlayer = !_animationIsPlayer; if (_isShowPlayer) &#123; // 播放 from 表示起点 _animationController.forward(from: 0); &#125; else &#123; // 倒放 from 表示起点 _animationController.reverse(from: 1); &#125; &#125;); &#125;, icon: const Icon(IconFontIcons.iconRight)), 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 【重要】你的组件一定要混入 SingleTickerProviderStateMixin 类class MyHomePage extends StatefulWidget &#123; const MyHomePage(&#123;super.key&#125;); @override State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; with SingleTickerProviderStateMixin &#123; late AnimationController _animationController; _animationIsPlayer = false; @override void initState() &#123; // 创建动画控制器 _animationController = AnimationController( vsync: this, duration: const Duration(milliseconds: 800), // 动画时长 reverseDuration: const Duration(milliseconds: 600) // 反向动画时长 ) &#125; // 页面销毁时 @override void dispose() &#123; // 销毁动画控制器 _animationController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Row( children: [ // 动画 SizeTransition( sizeFactor: _animationController, // 动画控制器 axis: Axis.horizontal, // 动画方向 axisAlignment: 0.0, // 基础位移 child: const Text(&quot;动画&quot;), ), // 按钮控制动画 SizedBox( height: 80, width: 50, child: IconButton( splashColor: Colors.transparent, highlightColor: Colors.transparent, hoverColor: Colors.transparent, onPressed: () &#123; setState(() &#123; _animationIsPlayer = !_animationIsPlayer; if (_isShowPlayer) &#123; _animationController.forward(from: 0); &#125; else &#123; _animationController.reverse(from: 1); &#125; &#125;); &#125;, icon: const Icon(IconFontIcons.iconRight)), ) ] ), &#125;&#125; 感谢观看，如果对你有帮助可以关注本站，龙小亦在此谢过了","tags":["flutter","ios","android"],"categories":["flutter"]},{"title":"vue批量注册全局自定义指令","path":"/2024/03/11/vue批量注册全局自定义指令/","content":"vue3批量注册自定义指令，又双叒叕踩坑了 之前在vue2中使用过批量注册指令的方法，不过vue2的模式在Vue3中竟然行不通了，我一脸懵逼的琢磨了大半个小时，最后还是用了一个不是很完美的方法 vue2中批量注册指令 在 @/utls/directives/init.js 中收集所有指令创建并进行注册 12345678910111213141516// @/utls/directives/init.jsimport directive1 from &#x27;@/utls/directives/directive1&#x27;import directive2 from &#x27;@/utls/directives/directive2&#x27;// 构建const directives = &#123; directive1, directive2,&#125;export default &#123; install (Vue) &#123; Object.keys(directives).forEach((key) =&gt; &#123; Vue.directive(key, directives[key]) &#125;) &#125;,&#125; 在 mian.js 中注入指令，就可以在Vue模板中使用指令了 1234// main.jsimport Vue from &#x27;vue&#x27;import directives from &#x27;./directives/index&#x27;Vue.use(directives) 如果还有疑问可以去看这位老兄的博客 https://blog.csdn.net/HH18700418030/article/details/128955606vue directive 批量注册自定义指令 vue3中批量注册指令 !!!这种写法不一定规范，但是能够解决指令无法注册的问题，步骤一样，方法有点出入 @/utls/directives/ 中插件的写法 123456789// @/utls/directives/directive1export default (Vue) =&gt; &#123; Vue.directive(&quot;directive1&quot;, &#123; created(el) &#123; // 逻辑代码 &#125;, ... &#125;)&#125; 在 @/utls/directives/init.js 中收集所有指令创建并进行注册 1234567891011121314// @/utls/directives/init.jsimport directive1 from &#x27;@/utls/directives/directive1&#x27;import directive2 from &#x27;@/utls/directives/directive2&#x27;// 构建指令队列const directives = [ directive1, directive2,]// 注册队列中所有的指令const initDeretives = (app) =&gt; &#123; directives.forEach(e =&gt; e(app))&#125;export default initDeretives; main.js 中注入插件 1234567// main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import initDeretives from &#x27;@/utils/derectives/index.js&#x27;const app = createApp(App)app.use(initDeretives)app.mount(&#x27;#app&#x27;) 感谢观看，如果对你有帮助可以关注本站，龙小亦在此谢过了","tags":["vue","笔记","踩坑"],"categories":["vue"]},{"title":"js中的节流防抖","path":"/2023/11/11/js中的节流防抖/","content":"关于防抖 概念：触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。 思路：每次触发事件的时候，清除定时器，然后从新设置新的定时器。 如何实现12345678910111213141516// 定义一个定时器let timer = null;let value = &quot;hello&quot;;function clickBut() &#123; let timer = null; // 创建一个闭包，保存一个标记用来存放定时器的返回值 return function () &#123; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; console.log(value); &#125;, 1000); &#125;;&#125;// 只能通过document.getElementById监听点击事件 button 上直接挂载 clickBut 函数，不会回调闭包中的函数document.getElementById(&quot;button1&quot;).addEventListener(&quot;click&quot;, clickBut);document.getElementById(&quot;button2&quot;).addEventListener(&quot;click&quot;, clickBut); 借助定时器就可以实现多次点击只会对最后一次点击生效 关于节流 概念：高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率。 思路：每此触发事件时判断是否定时器已满，满则重新定时，否则不做任何事。 如何实现1234567891011121314151617let value = &quot;hello&quot;;// 设置一个变量判断点击是否生效function clickBut() &#123; let canRun = true; // 通过闭包保存一个标记 return function (parmas) &#123; if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return canRun = false; // 立即设置为false setTimeout(() =&gt; &#123; // 将外部传入的函数的执行放在setTimeout中 console.log(value, parmas); // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉 canRun = true; &#125;, 500); &#125;;&#125;// 只能通过document.getElementById监听点击事件 button 上直接挂载 clickBut 函数，不会回调闭包中的函数document.getElementById(&quot;button1&quot;).addEventListener(&quot;click&quot;, clickBut(1));document.getElementById(&quot;button2&quot;).addEventListener(&quot;click&quot;, clickBut(2)); 看到这里我们可以通过代码就可以发现，防抖和节流都会阻止用户部分操作。区别就是在一定的时间内多次操作，防抖只会对最后一次操作生效，而节流每过一定时间都会对生效一次操作。应用：防抖：一般应用在只搜集用户最后一次操作：如用户多次点击按钮，多次提交表单等。节流：一般应用在用户频繁多次操作中起到限制请求次数：如用户频繁刷新列表等。 怎么通过vue全局指令完成防抖和节流在vue中有很多地方都会用到防抖和节流，防抖和节流的实现很见到。但如果在每个用到的地方都去写这写方法，那无疑是不明智的行为 vue3中的写法防抖在utils/derectives/debounce.js 注册插件 123456789101112131415161718192021222324252627// 注册插件export default (Vue) =&gt; &#123; Vue.directive(&quot;debounce&quot;, &#123; created(el, fn) &#123; // 监听点击事件，回调函数必须添加 () =&gt; ;不然会立即执行 el.addEventListener(&#x27;click&#x27;, () =&gt; clickHandler(fn)) &#125;, unmounted(el) &#123; // 组件卸载时移除监听事件 el.removeEventListener(&#x27;click&#x27;, clickHandler) &#125; &#125;)&#125;let timer = null;// 点击事件的回调函数function clickHandler(fn) &#123; // 创建一个闭包，保存一个标记用来存放定时器的返回值 let timer = null; return function () &#123; console.log(&quot;11213123&quot;, timer); clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn &amp;&amp; fn.value(); &#125;, 4000) &#125;&#125; xxx.vue 中使用 123456789101112&lt;template&gt; &lt;div&gt; &lt;button v-debounce=&quot;() =&gt; debounceHandler(1)&quot;&gt;按钮1&lt;/button&gt; &lt;button v-debounce=&quot;() =&gt; debounceHandler(2)&quot;&gt;按钮2&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;// 点击回调函数const debounceHandler = (id) =&gt; &#123; console.log(id)&#125;&lt;/script&gt; 节流在utils/derectives/debounce.js 注册插件 123456789101112131415161718192021222324252627// 注册插件export default (Vue) =&gt; &#123; Vue.directive(&quot;throtTleback&quot;, &#123; created(el, fn) &#123; // 监听点击事件，回调函数必须添加 () =&gt; ;不然会立即执行 el.addEventListener(&#x27;click&#x27;, () =&gt; clickHandler(fn)) &#125;, unmounted(el) &#123; // 组件卸载时移除监听事件 el.removeEventListener(&#x27;click&#x27;, clickHandler) &#125; &#125;)&#125;// 点击事件的回调函数function clickHandler(fn) &#123; // 创建一个闭包，保存一个标记用来存放定时器的返回值 let isCanClick = true; return function () &#123; if (!isCanClick) return; isCanClick = false; setTimeout(() =&gt; &#123; fn &amp;&amp; fn.value(); isCanClick = true; &#125;, 1000) &#125;&#125; xxx.vue 中使用 123456789101112&lt;template&gt; &lt;div&gt; &lt;button v-throtTleback=&quot;() =&gt; debounceHandler(1)&quot;&gt;按钮1&lt;/button&gt; &lt;button v-throtTleback=&quot;() =&gt; debounceHandler(2)&quot;&gt;按钮2&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;// 点击回调函数const debounceHandler = (id) =&gt; &#123; console.log(id)&#125;&lt;/script&gt; 感谢观看，如果对你有帮助可以关注本站，龙小亦在此谢过了","tags":["js","vue","js基础"],"categories":["js"]},{"title":"scss 实现日/夜间模式切换","path":"/2023/11/03/scss-实现日-夜间模式切换/","content":"有项目需要夜间模式，就开始寻找夜间模式的解决方案。因为项目本身用的是scss，所以思路是scss切换主题。 scss依赖安装(已安装的可以略过) 如果是用vite构建项目的，直接复制下面这段就好了。 shell1npm install sass -D 或者 shell1yarn add sass -D 如果是使用webpack构建项目的，安装下面的步骤。 安装依赖 123npm install node-sass sass-loader --save-dev 或yarn add node-sass sass-loader -D 在webpack配置文件中添加scss规则(在rules配置下)。 webpack.base.conf.js12345&#123; test: /\\.scss$/, loaders: [&#x27;style&#x27;, &#x27;css&#x27;, &#x27;sass&#x27;]&#125; 全局注册scss变量(有需要可以配置) 用vite构建项目的 vite.config.js1234567891011121314export default defineConfig(&#123; plugins:[vue()], // --- 这部分是需要添加的 --- //配置sass css: &#123; preprocessorOptions: &#123; // globalVar.scss 和 globalMixin.scss 为你需要全局注入的scss scss: &#123; additionalData: &#x27;@import &quot;../assets/scss/globalVar.scss&quot;;@import &quot;../assets/scss/globalMixin.scss&quot;;&#x27; &#125; &#125; &#125;, // --- 添加完毕 ---&#125;) 使用webpack构建项目的。 安装sass-resources-loader 123npm install sass-resources-loader --save-dev或yarn add sass-resources-loader -D 修改build/utils.js中的 exports.cssLoaders函数。 build/utils.js123456789101112131415161718192021222324252627282930// 定位文件function resolveResource(name) &#123; return path.resolve(__dirname, &#x27;../assets/scss/&#x27; + name);&#125;function generateSassResourceLoader() &#123; var loaders = [ cssLoader, &#x27;sass-loader&#x27;, &#123; loader: &#x27;sass-resources-loader&#x27;, options: &#123; // 多个文件时用数组的形式传入，单个文件时可以直接使用 path.resolve(__dirname, &#x27;../src/ // globalVar.scss 和 globalMixin.scss 为你需要全局注入的scss resources: [ resolveResource(&#x27;globalVar.scss&#x27;), resolveResource(&#x27;globalMixin.scss&#x27;), ] &#125; &#125; ]; if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, fallback: &#x27;vue-style-loader&#x27; &#125;) &#125; else &#123; return [&#x27;vue-style-loader&#x27;].concat(loaders) &#125;&#125; 修改之前的return build/utils.js123456789101112return &#123; css: generateLoaders(), postcss: generateLoaders(), less: generateLoaders(&#x27;less&#x27;), // sass: generateLoaders(&#x27;sass&#x27;, &#123; indentedSyntax: true &#125;), // scss: generateLoaders(&#x27;sass&#x27;), sass: generateSassResourceLoader(), scss: generateSassResourceLoader(), stylus: generateLoaders(&#x27;stylus&#x27;), styl: generateLoaders(&#x27;stylus&#x27;)&#125; 新建themes.scss(主题配置)文件，实现不同主题配色方案./styles/themes.scss1234567891011121314151617$themes: ( // 明亮主题 light: ( bg_color: #ffffff, font_color: #1c1c1e, border_color: rgba(0, 0, 0, 0.1) ), // 黑暗主题 dark: ( bg_color: hsla(0,0%,13%,1), font_color: #ffffff, border_color: rgba(255, 255, 255, 0.4) ));// 这个是为了后面演示$--n-border-r: 4px; 新建handleTheme.scss文件，控制主题配色。./styles/handleTheme.scss12345678910111213141516171819202122232425262728293031323334353637383940// 引入刚才建立的主题配色样式文件@import &quot;./themes.scss&quot;;//遍历主题map@mixin themeify &#123; @each $theme-name, $theme-map in $themes &#123; //!global 把局部变量强升为全局变量 $theme-map: $theme-map !global; //判断html的data-theme的属性值 #&#123;&#125;是sass的插值表达式 //&amp; sass嵌套里的父容器标识 @content是混合器插槽，像vue的slot [data-theme=&quot;#&#123;$theme-name&#125;&quot;] &amp; &#123; @content; &#125; &#125;&#125;// 声明一个根据Key获取颜色的function@function themed($key) &#123; @return map-get($theme-map, $key);&#125;// 获取背景颜色@mixin background_color($color) &#123; @include themeify &#123; background-color: themed($color)!important; &#125;&#125;// 获取字体颜色@mixin font_color($color) &#123; @include themeify &#123; color: themed($color)!important; &#125;&#125;// 获取边框颜色@mixin border_color($color) &#123; @include themeify &#123; border-color: themed($color)!important; &#125;&#125; 切换主题在app.vue或者需要用到主题切换的组件中。 app.vue123456789101112131415161718192021// 在js部分import &#123; onMounted, ref &#125; from &quot;vue&quot;;// 可以将主题配置写在浏览器storage中。const theme = ref(window.localStorage.getItem(&quot;theme&quot;) || &quot;light&quot;);// 加载主题onMounted(() =&gt; &#123; window.document.documentElement.setAttribute(&quot;data-theme&quot;, theme.value);&#125;);// 切换主题const changeTheme = () =&gt; &#123; if (theme.value === &quot;light&quot;) &#123; theme.value = &quot;dark&quot;; &#125; else &#123; theme.value = &quot;light&quot;; &#125; window.localStorage.setItem(&quot;theme&quot;, theme.value); window.document.documentElement.setAttribute(&quot;data-theme&quot;, theme.value);&#125;; 如何使用样式./components/xxx.vue123456789101112131415161718// 如果没有将 handleTheme.scss 注册到全局的话需要先引入@import &quot;@/styles/handleTheme.scss&quot;;.details-area, .comment-area &#123; background-color: #FFFFFF; // 使用mixin @include background_color(&quot;bg_color&quot;); // 使用变量 border-radius: $--n-border-r;&#125;.community-topic-title &#123; font-weight: 700; font-size: 22px; color: #000; @include font_color(&quot;font_color&quot;); padding-top: 0.195rem;&#125; scss 非常强大，语法也比较多，感兴趣的可以访问官网。 https://www.sass.hk/https://www.sass.hk/ 需要注意的是： 一般建议主题配置样式和其他全局样式分开写，本文中在主题配置样式文件中加入全局样式本身就是不正确的。 主题样式和全局样式一般建议全局注册，除非是对项目构建后的大小有要求。 感谢观看，如果对你有帮助可以关注本站，龙小亦在此谢过了","tags":["css","scss"],"categories":["css"]},{"title":"css:text-align 两端对齐常见问题","path":"/2023/10/16/css:text-align 两端对齐常见问题/","content":"兼容性问题text-align: justify;两端对齐IE、火狐不兼容解决方案text-align: justify;在火狐与IE中不起作用。加上下边两行就阔以啦！ 123text-align: justify;word-break: break-all;text-justify: distribute; 单行无法两端对齐text-align: justify;最后一行是无法生效的，如果只有一行，就会默认为是最后一行。我们可以通过设置justify-all或者text-align-last就阔以解决这个问题 123justify-all: justify;/* 或者 */text-align-last: justify; 需要注意的是text-align-last并不是所有浏览器都支持的！ 如果遇到了不支持text-align-last的浏览器，可以通过::after伪元素模拟一行 12345::after &#123; content: &quot;&quot;; display: inline-block; width: 100%;&#125; 需要注意的是这样会增加元素的高度。 感谢观看，如果对你有帮助可以关注本站，龙小亦在此谢过了","tags":["css"],"categories":["css"]},{"title":"js 中无法监听到onScroll事件","path":"/2023/06/16/js中无法监听到onScroll事件/","content":"问题描述有个项目中，需要监听子组件中是否滑动，最初想到了window全局监听，却发现根本监听不到。后想到onScrollApi，这次记录一下在onScrollApi中踩过的坑。 样例1234567891011121314151617181920&lt;div&gt; &lt;div onScroll=&quot;onScrollCB()&quot; class=&quot;scrollDiv&quot;&gt; &lt;img src=&quot;https://img0.baidu.com/it/u=554275960,1123388892&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500&quot; /&gt; &lt;img src=&quot;https://img0.baidu.com/it/u=554275960,1123388892&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500&quot; /&gt; &lt;img src=&quot;https://img0.baidu.com/it/u=554275960,1123388892&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500&quot; /&gt; &lt;img src=&quot;https://img0.baidu.com/it/u=554275960,1123388892&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500&quot; /&gt; &lt;img src=&quot;https://img0.baidu.com/it/u=554275960,1123388892&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500&quot; /&gt; &lt;img src=&quot;https://img0.baidu.com/it/u=554275960,1123388892&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500&quot; /&gt; &lt;/div&gt; 你好 你好 你好 &lt;/div&gt; &lt;script&gt; window.addEventListener(&quot;scroll&quot;, () =&gt; &#123; console.log(&quot;全局滑动&quot;); &#125;); function onScrollCB() &#123; console.log(&quot;div内滑动&quot;); &#125; &lt;/script&gt; 如果上面那样写，其实永远无法打印div内滑动，因为滑动事件并没有发生在所监听的div中，只有滑动发生在所监听的div中onScroll才会被触发。 解决解决方法其实很简单，给需要监听的div添加一个高度限制，并允许滑动。就能让滑动发生在div内。 1234.scrollDiv &#123; height: 400px; overflow: auto;&#125; 需要注意的是，div内内容的高度必须高于或宽度宽于div所限制的高度或宽度，才能让div滑动起来。 感谢观看，如果对你有帮助可以关注本站，龙小亦在此谢过了","tags":["js"],"categories":["js"]},{"title":"docker部署Haoop集群","path":"/2023/05/19/docker部署Haoop集群/","content":"使用docker部署Haoop集群 技术栈结构12345678# hadoop集群版本hadoop-3.3.1# java版本OpenJDK8U-jdk_x64_linux_hotspot_8u322b06 # 清华源上下载# centos版本centos7# docker版本docker 20.10.12 网络ip分配123456# 网络集群172.18.0.0# 采用一主两从搭建 hadoop完全分布式masert 172.18.0.10salver01 172.18.0.11salver02 172.18.0.12 创建一个docker-ent 网络1docker network create --driver bridge --subnet 172.18.0.0/16 --gateway 172.18.0.1 HadoopClusterEnt 构建hadoop+jdk+centos的镜像123456789101112131415161718192021222324252627282930313233343536373839# DockerfileFROM centos:7# 镜像的作者MAINTAINER long&lt;31742145@qq.com&gt;# 安装openssh-server和sudo软件包，并且将sshd的UsePAM参数设置成noRUN yum install -y openssh-server sudoRUN sed -i &#x27;s/UsePAM yes/UsePAM no/g&#x27; /etc/ssh/sshd_config#安装openssh-clientsRUN yum install -y openssh-clients# 添加测试用户root，密码root，并且将此用户添加到sudoers里RUN echo &quot;root:root&quot; | chpasswdRUN echo &quot;root ALL=(ALL) ALL&quot; &gt;&gt; /etc/sudoersRUN ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_keyRUN ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key# 启动sshd服务并且暴露22端口RUN mkdir /var/run/sshdEXPOSE 22# 添加jdk和hadoopADD OpenJDK8U-jdk_x64_linux_hotspot_8u322b06.tar.gz /usr/localADD hadoop-3.3.1.tar.gz /usr/local# 添加环境ENV JAVA_HOME /usr/local/jdk8u322-b06ENV HADOOP_HOME /usr/local/hadoop-3.3.1ENV PATH $PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbinEXPOSE 9870EXPOSE 8088CMD [&quot;/usr/sbin/sshd&quot;, &quot;-D&quot;]WORKDIR /usr/localENTRYPOINT /usr/sbin/init# 构建 imagedocker build -t long/centos-hadoop . 构建master、salver01、salver02容器12345678# masterdocker run -d --name master --hostname master -p 9870:9870 -p 8088:8088 --network HadoopClusterEnt --ip 172.18.0.10 --privileged=true long/centos-hadoop # salver01docker run -d --name salver01 --hostname salver01 --network HadoopClusterEnt --ip 172.18.0.11 --privileged=true long/centos-hadoop # salver02docker run -d --name salver02 --hostname salver02 --network HadoopClusterEnt --ip 172.18.0.12 --privileged=true long/centos-hadoop 启动master、salver01、salver02容器12345678# 启动masterdocker exec -it master /bin/bash# 启动salver01docker exec -it salver01 /bin/bash# 启动salver02docker exec -it salver02 /bin/bash 配置Hadoop集群初始化Hadoop集群启动Hadoop集群"},{"title":"docker常用命令","path":"/2023/05/19/docker常用命令/","content":"Docker常用命令 运行一个docker实例1docker run xxx # xxx是实例的名称，如hello-world 查看本地docker镜像信息1docker images 卸载docker123456# ubnutu 下# 卸载docker引擎，应用程序sudo apt-get purge docker-ce docker-ce-cli containerd.io# 删除docker镜像，资源 sudo rm -rf /var/lib/docker # docker的默认工作路径 sudo rm -rf /var/lib/containerd 帮助命令123docker vsersion # 显示docker信息docker info # 显示docker的系统信息docker 命令 --help [docker官方命令地址](Reference documentation | Docker Documentation) 镜像命令123456789101112131415161718192021docker login # 登录dockerhub 账号，有些镜像需要账号才能下载docker images # 查看所有docker镜像docker search java # 搜索镜像docker pull ascdc/jdk8 # 下载镜像 Using default tag: latest # 默认拉取最新版本 latest: Pulling from ascdc/jdk8 297061f60c36: Pull complete # 分层下载( 如果下载其他镜像有相同的层时就不会重复下载 ) e9ccef17b516: Pull complete dbc33716854d: Pull complete 8fe36b178d25: Pull complete 686596545a94: Pull complete dfa7782be422: Pull complete 25d4d9080d04: Pull complete 0615a7c60138: Pull complete a8a7a10db50a: Pull complete Digest: sha256:44af3f9184a2fde277ccd785f47bfe2ef3f04f2c35bf6d92adf4b40cb585a5f7 #标签 Status: Downloaded newer image for ascdc/jdk8:latest docker.io/ascdc/jdk8:latest # 真实的仓库地址docker rmi -f (imgaeId/imageName) # 删除image，多个中间加空格docker rmi -f $(docker images -qa) # 删除所有的image 容器命令12345678910111213141516171819202122232425262728293031323334353637# 下载镜像并运行镜像docker run [参数] images## 参数--name=&quot;Name&quot; #容器名字-d #后台运行-it # 使用交互模式运行-p # 指定一个port运行容器\t-p ip:主机端口:容器端口\t-p 主机端口:容器端口 ( 常用 )\t-p 容器端口-P # 随机一个port# 启动并进入容器long@ltp:/$ docker run -it centos /bin/bash[root@04f98154528b /]## 退出命令exit # 会关闭容器ctrl + P + Q # 不关闭容器退出# 列出所有运行的命令docker psdocker ps -adocker ps -a -n=1 # 显示最后一次运行的容器docker ps -qa# 删除容器docker rm #容器Iddocker rm -f $( docker ps -aq ) #删除所有容器# 启动和停止容器docker start 容器Id # 启动一个容器docker restart 容器Id # 重启一个容器docker stop 容器Id docker kill 容器Id# 重新进入容器docker exec -it 容器Id /bin/bashdocker attach 容器Iddocker exec # 开启一个新的终端 ( 常用 )docker attach # 使用容器之前的终端 常用的其他命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 后台启动容器docker run -d centos# 常见的问题# docker 容器使用后台运行，就必须要有一个前台应用，docker发现没有前台应用，就会自动停止# 查看日志-tf-tail 10 显示10行日志docker --logs 容器Id# 查看容器中的进程信息docker top 容器Id# 查看容器内部信息docker inspect 容器Id# 从容器内拷贝文件到宿主机上docker cp 容器Id:/文件地址 宿主机目标目录# 查看容器 资源状态docker stats# 提交容器 -&gt; 将一个容器打包成一个新的镜像# 首先需要运行容器docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器Id [Tag信息]# 查看 image build的步骤docker history imageName/imageId# 数据持久化/数据卷挂载docker run -it -v 宿主目录:容器目录 # 匿名挂载\t-v 容器目录\tDRIVER VOLUME NAME\tlocal 2ddc412e3e1d7274549550589ed28bd16f2a8d9ab899d9d853edcac504c5e8e5\t# 具名挂载\t-v 具名:容器目录\t# 区分具名挂载、匿名挂载和指定目录挂载docker -v 容器目录 # 匿名挂载docker -v 具名:容器目录 # 具名挂载dokcer -v /宿主机路径:容器目录 # 指定目录挂载# 拓展# ro readOnly 只读权限# rw readWriter 读写权限docker -v 容器目录:[ro|rw]\t# 查看所有数据卷docker vloume ls# 提交镜像# 提交镜像之前需要先登录账号# docker hubdocker pull authorName/imageName:[Tag]# 修改image信息docker tag imageId 修改之后的信息# 查看所有的docker网络docker network ls","tags":["docker","linux"],"categories":["docker"]},{"title":"sqoop","path":"/2023/05/19/sqoop/","content":"sqoop基础 使用sqoop连接mysql时，如果java的版本过高有密码安全机制 查询时需要在mysql地址后加上 useSSL&#x3D;false sqoop -list-databases --connect jdbc:mysql://localhost:3306?useSSl=false --username root -password long 将mysql的数据导入到hdfs上 1sqoop import --connect jdbc:mysql://localhost:3306/testDatabase?useSSl=false --username root -password long --table tableName --columns &#x27;id,name&#x27; import 会将mysql的数据导入到hdfs中 将mysql数据的表结构复制到hive中1sqoop create-Hive-table --connect jdbc:mysql://localhost:3306/testDatabase?useSSL=false --username root -password long --table tableName --hive-table users --fields-terminated-by &quot;,&quot; 将数据从mysql数据库导入文件到hive表中——import12345sqoop import --connect jbdc:mysql://localhost:3306/testDatabase --username root --password long --table tableName--hive-import --hive-table users -m 2 --fields-terminated-by &quot;,&quot; 参数说明： 1、-m 2 表示由两个map作业执行； 2、–fields-terminated-by “,” 需同创建hive表时保持一致； 注意：先根据mysql表的结构得到hive表，然后将mysql表中的数据导入到hive表（也就是导入到HDFS，因为hive表的数据是存在hdfs上的warehouse） –columns –where 语句使用123456sqoop import --append --connect jdbc:mysql://loclhost:3306/test --username root --password long --table tableName --columns &quot;id,age,name&quot; --where &quot;id &gt; 3 and (age = 88 or age = 80)&quot; -m 1 --hive-import --hive-table userinfos2--fields-terminated-by &quot;,&quot;; 追加导入123sqoop import --connect jdbc:mysql://db.foo.com/somedb --table sometable--where &quot;id &gt; 100000&quot; --target-dir /incremental_dataset –append 将hive的数据导入到myslq123456sqoop export --connect jdbc:mysql://localhost:3306/trafficdata?useSSL=false --username root --password hadoop -table order_province_time --export-dir /user/hive/warehouse/trafficdata.db/order_province_time--input-fields-terminated-by &#x27;\\001&#x27; Hive 的元数据在mysql中，但是Hive的数据存在hdfs上 hive数据库保存的路径 &#x3D;&gt; &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;trafficdata.db hive默认的字段分隔符为’\\001’ 如果出现拒绝连接的错误信息，请检查mysql中root是否开放远程连接，后将localhost改为ip地址。或者开启hive metastore 服务 其他sqoop常用命令sqoop常用命令","tags":["linux","hive","sqoop","mysql"],"categories":["sqoop"]},{"title":"docker部署","path":"/2023/05/19/docker部署/","content":"docker 常见部署方式 nginx12345678# 1. 拉取nginx镜像docker pull nginx# 2.运行nginx镜像# -d 后台运行# -name 给容器设置一个name# -p 暴露端口 将容器内的80 暴露到宿主机上的3000上docker run -d --name nginx01 -p 3000:80 nginx tomcat1234567891011# 1. 拉取tomcat镜像 -- 拉取指定版本docker pull tomcat:9.0# 2.运行tomcat镜像# -d 后台运行# -name 给容器设置一个name# -p 暴露端口 将容器内的8080 暴露到宿主机上的3000上docker run -d --name tomcat01 -p 3000:8080 tomcat# --rm 停止容器后删除容器 ( 一般用于测试 )docker run -d --name --rm tomcat01 -p 3000:8080 tomcat 12# -e 添加环境配置docker run -d --name elasticsearch02 -p 9999:9300 -p 9998:9200 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch 自定义tomcat image12345678910111213141516171819202122232425262728# 编写dockerfileFROM centosMAINTAINER long&lt;317742145@qq.com&gt;ADD OpenJDK8U-jdk_x64_linux_hotspot_8u322b06.tar.gz /usr/local/ADD apache-tomcat-9.0.56.tar.gz /usr/localENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/OpenJDK8U-jdk_x64_linux_hotspot_8u322b06ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.56ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.56ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/bin:$CATALINA_HOME/libEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.56/bin/startup.sh # 构建 image 如果dockerFile的名字为 Dockerfile 的话就可以省略不加 -f 参数docker build -f Dockerfile -t dittomcat ./docker run -d -p 9090:8080 --name diytomcat01 -v /home/long/tomcat/test:/usr/local/apache-tomcat-9.0.56/webapps/test -v /home/long/tomcat/logs:/usr/local/apache-tomcat-9.0.56/logs diytomcatdocker run -it -p 9090:8080 --name diytomcat01 -v /home/long/tomcat/test:/usr/local/apache-tomcat-9.0.56/webapps/test -v /home/long/tomcat/logs:/usr/local/apache-tomcat-9.0.56/logs diytomcat /bin/bash","tags":["docker","linux"],"categories":["docker"]},{"title":"docker","path":"/2023/05/09/docker/","content":"什么是docker Docker 的基本组成 镜像( image ) docker 镜像好比是一个模板，可以通过这个模板来创建容器服务。 容器( container ) docker 利用容器技术，独立运行一个或者一组应用，通过镜像来创建。 启动，停止，删除等基本命令 1. 仓库( repository ) ​ 仓库是存放镜像的地方，( 共有和私有仓库 ) 安装Docker12345678910111213141516171819202122232425# ubuntu 下# 1.卸载旧的版本 sudo apt-get remove docker docker-engine docker.io containerd runc# 2.设置仓库sudo apt-get updatesudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release # 3.切换成国内的镜像源 curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\$(lsb_release -cs) stable&quot; # 4.更新软件包缓存 sudo apt update # 5.安装docker 服务 sudo apt-get install docker-ce docker-ce-cli containerd.io # 6.启动docker sudo service docker start # docker 测试 # 查看docker 版本信息 docker verison # 运行一个docker实例 sudo docker run hello-world docker底层docker 是一个 client-server 结构的系统，docker的守护进程运行在主机( 宿主 )上。通过Socket从客户端访问。docker-server 接收到 docker-client 之后就会去运行。 docker为什么比VM快 docker比VM有更少的抽象层。 docker利用的是宿主机的内核 docker 容器数据卷什么是容器数据卷？ 如果数据都在容器中，我们将容器删了就会导致数据丢失 &#x3D;&#x3D;需求：数据持久化&#x3D;&#x3D; 容器之间数据共享 docker容器中的数据同步到本地 &#x3D;&#x3D;将容器数据目录挂载到宿主机上！&#x3D;&#x3D; 使用数据卷1docker run -it -v 宿主目录:容器目录 DockerfiledockerFile 是用来构建一个docker image的文件 12345# 自定义DockerFileFROM centosVOLUME [“volume01”,“volume02”]CMD echo &quot;-----end-----&quot;CMD /bin/bash 123456789101112131415161718192021# 构建Docker miagedocker bulid -f 构建miage使用的文件 -t images名字 images保存目录# Sending build context to Docker daemon 2.048kBStep 1/4 : FROM centos ---&gt; 5d0da3dc9764Step 2/4 : VOLUME [&#x27;volume01&#x27;,&#x27;volume02&#x27;] ---&gt; Running in d8eb0d2ef56eRemoving intermediate container d8eb0d2ef56e ---&gt; 5fc6e1709489Step 3/4 : CMD echo &quot;-----end-----&quot; ---&gt; Running in f2b5b231b3b0Removing intermediate container f2b5b231b3b0 ---&gt; 48f502e08ca4Step 4/4 : CMD /bin/bash ---&gt; Running in e916a60079d8Removing intermediate container e916a60079d8 ---&gt; 1a522655fe62Successfully built 1a522655fe62Successfully tagged long/centos:latest DockerFile构建基础知识 1. 每个关键字都必须是大写 1. 执行顺序是从上到下 1. #表示注释 1. 每个指令都会构建一层新的镜像，并提交！ DockerFile指令123456789101112FROM # 基础镜像，一切从这里开始构建MAINTAINER # 作者， 名字+邮箱RUN # 运行的命令ADD # 添加新的内容，会自动解压压缩包WORKDIR # 镜像工作目录VOLUME # 挂载的目录EXPOSE # 暴露端口CMD # 指定这个容器运行的命令，只有最后一个会生效ENTRPOINT\t# 追加命令ONBUILD # 当构建一个被继承 DockerFile 就会触发这个指令COPY # 类型ADD,将我们的文件拷贝到镜像中，不会自动解压压缩包ENV # 构建时设置环境变量 ​\t编写一个自己的centos 12345678910111213141516171819# 编写一个 dockerFileFROM centosMAINTAINER long&lt;317742145@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;---end---&quot;CMD /bin/bash# 构建 docker Imagedocker build -f dockerFile名字 -t 镜像名 ./ 容器卷自动挂载技术--volumes-from 12345678# 将一个容器的数据卷和另外一个容器的数据卷挂载到一起# 先启动一个 自定义的centos 里面加入了数据卷docker run -it --name centos01 long/centos /bin/bash# 启动第二个 自定义centos时 使用容器卷自动挂载docker run -it --name centos02 --volumes-from centos01 long/centos /bin/bash# 此时 第一个容器会产生对应的 volume 卷，第二个容器会使用第一个容器已经产生了的 volume 卷，就不会产生新的 volume 卷 Docker网络 docker0 就是docker在虚拟机中的地址 1234567891011121314151617181920# 先运行一个 容器 # ip addr 我们就可以得到容器内部的地址docker run -it --name centos01 centos ip addr# eth0@if57 eth0@if 开头的就是 docker给容器分配的地址1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000 link/ipip 0.0.0.0 brd 0.0.0.03: sit0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000 link/sit 0.0.0.0 brd 0.0.0.056: eth0@if57: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # 容器和容器之间是可以相互ping通的 自定义网络123456789# 创建了一个名为 mynet的网络组# --driver 网络模式# --subnet 子网地址# --gateway 网关地址docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet# 新建容器时可以指定加入到自定义网络中docker run -d -P --name tomcat-net-01 --net mynet tomcat","tags":["docker","linux"],"categories":["docker"]},{"title":"vue 图片懒加载","path":"/2023/03/24/vue-图片懒加载/","content":"什么是图片懒加载 在前端每个页面通常会有很多请求，而绝大多数浏览器每次默认的最大并发请求数为6个。这样就会导致请求很多时，请求需要排队，导致网页响应较慢，此文章就会采用图片懒加载的方法，将图片请求放在最合适的地方（当窗口出现图片时），加快网页响应速度。举个例子：类似于大型的淘宝商城、京东等网页，设计大量的商品图片信息，如果我们使页面包含的所有图片一次性加载完成，那用户体验很差。目前流行的做法是滚动动态加载，也就是懒加载，显示在屏幕之外的图片默认不加载，随着页面的滚动，图片进入了显示的范围，则触发图片的加载显示这样做的好处，一是页面加载速度快(浏览器进度条和加载转圈很快就结束了，这样用户的体验也比较好)，而是节省流量，因为不可能每一个用户会把页面从上到下滚动完 图片懒加载的原理--三种方法实现https://blog.csdn.net/darabiuz/article/details/123151266 实现废话不多说，直接看实现 原生js如果事先没有将图片src属性保存到其他属性上 12345678910document.addEventListener(&#x27;DOMContentLoaded&#x27;, function () &#123; // 获取所有图片信息 let imgs = document.getElementsByTagName(&#x27;img&#x27;); Array.from(imgs).forEach(element =&gt; &#123; // 将src属性保存到data-src上 element.setAttribute(&#x27;data-src&#x27;, element.getAttribute(&#x27;src&#x27;)) // 将src属性修改为加载中图片 element.setAttribute(&#x27;src&#x27;, &#x27;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc68fd7bffd417c9cc874b4a12612be~tplv-k3u1fbpfcp-zoom-crop-mark:1956:1956:1956:1101.image&#x27;) &#125;)&#125;) 通过DOMContentLoaded生命周期函数，将img的src保存到data-src中，将src设置为加载中信息 1234567891011121314151617181920window.onload = () =&gt; &#123; // 获取所有图片信息 let imgs = document.getElementsByTagName(&#x27;img&#x27;) // 1. 一上来立即执行一次 let io = new IntersectionObserver(function (entires) &#123; //图片进入视口时就执行回调 entires.forEach(item =&gt; &#123; // 获取目标元素 let oImg = item.target // 当图片进入视口的时候，就赋值图片的真实地址 if (item.intersectionRatio &gt; 0 &amp;&amp; item.intersectionRatio &lt;= 1) &#123; oImg.setAttribute(&#x27;src&#x27;, oImg.getAttribute(&#x27;data-src&#x27;)) &#125; &#125;) &#125;) Array.from(imgs).forEach(element =&gt; &#123; io.observe(element) //给每一个图片设置监听 &#125;);&#125; 通过IntersectionObserver监听图片是否出现在显示窗口，如果出现在显示窗口就将 data-src 中的信息重新给 src vue 指令实现123456789101112131415161718// lazy 指令部分const lazy = (app) =&gt; &#123; app.directive(&#x27;lazy&#x27;, (el) =&gt; &#123; // 加载中src el.src = &quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dc68fd7bffd417c9cc874b4a12612be~tplv-k3u1fbpfcp-zoom-crop-mark:1956:1956:1956:1101.image&quot; const obServer = new IntersectionObserver(entries =&gt; &#123; if (entries[0].intersectionRatio &lt;= 0) return // 将data-src给src el.src = el.dataset.src // 取消监听 obServer.unobserve(el) &#125;) // 监听 obServer.observe(el); &#125;)&#125;export default lazy; 1234567891011121314// 指令使用&lt;template&gt; &lt;div&gt; &lt;div class=&quot;title&quot;&gt;vue lazy&lt;/div&gt; &lt;img v-lazy data-src=&quot;https://img1.baidu.com/it/u=413643897,2296924942&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500&quot; /&gt; &lt;img v-lazy data-src=&quot;https://img.tukuppt.com/photo-big/00/00/94/6152bc0ce6e5d805.jpg&quot; /&gt; &lt;/div&gt;&lt;/template&gt; 实现原理其实通过代码就可以看出，图片加载是通过src属性去获取图片信息，而图片懒加载就是现将src给另外一个属性，当屏幕滑动到图片时，再将刚才的属性从新赋回给src，img就会去拉图片信息。这样就完成了图片懒加载。 未使用图片懒加载 使用图片懒加载 对比可以看出来图片懒加载的优化还挺不错的，尤其是在图片越多的时候优化就越明显 感谢观看，如果对你有帮助可以关注本站，龙小亦在此谢过了","tags":["js","vue","html"],"categories":["vue"]},{"title":"flink部署模式","path":"/2023/02/19/flink部署模式/","content":"Filnk部署模式 1.standalone模式1234567891011121314151617181920212223242526# standalone 模式的部署只需要修改两个配置文件 - $FLINK_HOME/conf# 1.flink-conf.yaml# jobmanager.rpc.address 指定jobmanager的address(主节点，ip地址或者主机名皆可)jobmanager.rpc.address: master# jobmanager.rpc.port 指定jobmanager的通信端口(一般为默认)jobmanager.rpc.port: 6123# jobmanager.memory.process.size 指定jobmanager的内存大小jobmanager.memory.process.size: 1600m# taskmanager.memory.process.size 指定taskmanager的内存大小taskmanager.memory.process.size: 1728m# taskmanager.numberOfTaskSlots 指定taskmanager的插槽数量taskmanager.numberOfTaskSlots: 2# 2.workers文件# workers 文件用于指定taskmanager的节点主机(ip地址或者主机名皆可)worker1worker2# 3.启动standalone模式$FLINK_HOME/bin/start-cluster.sh# 4.检查是否运行成功 - jps查看进程# jobmanager节点进程为StandaloneSessionClusterEntrypoint # jobmanager的守护进程# taskmanager节点进程为TaskManagerRunner # taskmanager的守护进程 最后可以查看主节点的8081端口查看 flink webUI","tags":["linux","flink"],"categories":["flink"]},{"title":"flink本地调试配置","path":"/2023/02/12/flink本地调试配置/","content":"Flink本地调试配置 1.本地调试配置webUI1234567&lt;!-- pom文件添加webUI依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-runtime-web_$&#123;scala.binary.version&#125;&lt;/artifactId&gt; &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 12345// 创建flink上下文的时候需要选择创建带有webUI的上下文对象Configuration configuration = new Configuration();// 设置webUI的端口号，默认为8081端口configuration.setInteger(&quot;rest.port&quot;, 9999);StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(configuration);","tags":["flink","java"],"categories":["flink"]},{"title":"flink常用依赖包","path":"/2023/01/27/flink常用依赖包/","content":"flink常用依赖包 provided 表示不使用此依赖，如果被注释了表示使用此依赖，没有被注释表示不使用此依赖。本地调试的时候选择注释，打包到服务器上运行时如果服务器上有flink的依赖可以选择不注释，不把依赖打入jar包中。 1. flink-java 依赖包(java代码写kafka)123456&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-java&lt;/artifactId&gt; &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2.flink steram 依赖包(java版本)123456&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-streaming-java_$&#123;scala.binary.version&#125;&lt;/artifactId&gt; &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3.flink steram 依赖包(scala版本)123456&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-streaming-scala_$&#123;scala.binary.version&#125;&lt;/artifactId&gt; &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 4.flink webUI 依赖包(flink本地测试时使用)123456&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-runtime-web_$&#123;scala.binary.version&#125;&lt;/artifactId&gt; &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 5.flink 连接依赖包123456&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-clients_$&#123;scala.binary.version&#125;&lt;/artifactId&gt; &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 6.flink-kafka 连接依赖包1234567&lt;!-- _2.12 表示kafka的版本 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-kafka_2.12&lt;/artifactId&gt; &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;","tags":["flink","java"],"categories":["flink"]},{"title":"flink基础","path":"/2023/01/27/flink基础/","content":"Flink基础 flink 运行时的组件 JobManager ( 作业管理器 ) TaskManager ( 任务管理器 ) ResourceManager ( 资源管理器 ) Dispacher ( 分发器 ) flink standalone 模式运行流程 flink Per Job Cluster 模式运行流程 flink抽象数据集 DataSet -&gt; 批处理抽象数据集 DataStream -&gt; 流式抽象数据集 ​source 负责数据读取​transformation 负责对数据进行转换操作 ( 类似于spark中的转化算子 )​sink 负责对最后的结果进行 source source分为单并行的source和多并行的source 单并行的source: 通过实现 sourceFunction 接口 socketTextStream fromCollection fromElements 多并行的source 通过实现 ParallelSourceFunction 接口 fromCollection","tags":["flink"],"categories":["flink"]},{"title":"hive-UDF","path":"/2021/12/30/hive-UDF/","content":"Hive-UDF自定义函数 maven项目导包12345678910111213141516171819&lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;hadoop.version&gt;2.6.0&lt;/hadoop.version&gt; &lt;hive.version&gt;1.1.0&lt;/hive.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;$&#123;hadoop.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hive&lt;/groupId&gt; &lt;artifactId&gt;hive-exec&lt;/artifactId&gt; &lt;version&gt;$&#123;hive.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 新建Hive-UDF类123456789101112131415161718192021222324252627282930313233// Hive UDF 需要实现 UDF// UDF =&gt; import org.apache.hadoop.hive.ql.exec.UDF;import org.apache.hadoop.hive.ql.exec.UDF;import org.apache.hadoop.io.Text;public class AvgCost extends UDF &#123; // UDF 必须有个 evaluate 方法，也可以有多个实现重载 // evaluate 返回的数据类型必须是 java 基础类型或Hadoop Writerbel 数据类型 // 建议Hadoop Writerbel 数据类型, 因为底层是MR // 返回的数据类型必须是 Text public Text evaluate (Text input)&#123; Text output = new Text(); if (!input.toString().isEmpty())&#123; output.set(&quot;None&quot;); &#125; String[] salary = input.toString().split(&quot;-&quot;); if (salary.length == 1)&#123; output.set(salary[0] + &quot; - &quot; + salary[0]); &#125; if (salary.length == 2)&#123; int salary1 = Integer.parseInt(salary[0]); int salary2 = Integer.parseInt(salary[1]); Double avgSalary = (salary1+salary2)*1.0/2; if (salary1 &gt; salary2)&#123; output.set(salary1 + &quot; - &quot; + salary2 + &quot; - &quot; + avgSalary); &#125;else&#123; output.set(salary2 + &quot; - &quot; + salary1 + &quot; - &quot; + avgSalary); &#125; &#125; return output; &#125; 打jar包上传到服务器 略 添加jar包到hive中，并导入函数123456789101112131. 导入jar包hive&gt; add jar jar包路径2. 导入函数 -语法: crate [temporary] function [dbName]functionName as &#x27;packageAddress&#x27; -a 导入成临时函数hive&gt; create temporary function avgcost as &#x27;com.org.udf.AvgCost.AvgCost&#x27;; -b 导入成永久函数hive&gt; create function dbName.avgcost as &#x27;com.org.udf.AvgCost.AvgCost&#x27;;// 导入成永久函数可以决定作用域[dbName] 是哪个数据库，函数就只能在哪个数据库中调用，临时函数无法指定3.使用函数 =&gt; 直接用函数名就可以调用hive&gt; select avgcost(salary) as salary from rawData;","tags":["java","hive"],"categories":["hive"]},{"title":"hive窗口函数","path":"/2021/12/24/hive窗口函数/","content":"Hive窗口函数 测试数据集 name orderdate cost jack 2017-01-01 10 tony 2017-01-02 15 jack 2017-02-03 23 tony 2017-01-04 29 jack 2017-01-05 46 jack 2017-04-06 42 tony 2017-01-07 50 jack 2017-01-08 55 mart 2017-04-08 62 mart 2017-04-09 68 neil 2017-05-10 12 mart 2017-04-11 75 neil 2017-06-12 80 mart 2017-04-13 94 题目查询在2017年4月份购买过的顾客及总人数1select name,count(*) over() from test1 where substring(orderdate, 1, 7) = &#x27;2017-04&#x27; group by name;查询顾客的购买明细及购买总额1select *,sum(cost) over() from test1;累计计算求每个人消费金额及购买总额，按照日期进行累加1select orderdate,sum(cost) over(order by orderdate) from test1;求每个人消费金额及购买总额，按人按时间累加1select name, orderdate,cost,sum(cost) over(distribute by name) from test1;查询顾客上次的购买时间1select name,orderdate,cost,lag(orderdate, 1) over(partition by name order by orderdate) from test1; whyover案例over()函数over() 必须写在聚合函数后面，order() &#x3D;&gt; 开窗这个窗口就是一部分数据集， 数据集的作用范围是 前面的聚合函数（只有前面的聚合函数能够使用到窗口里面的数据）over() 里面可以传参，如果不传参就是对整个数据集进行开窗（将整个数据集放到一个窗口中）over() 聚合函数前，有多少条数据就开几次窗参数说明123456789over() 中的参数说明\t=&gt; current row : 当前行\t=&gt; n preceding : 往前n行\t=&gt; n following : 往后n行\t=&gt; unbounded : 起点\t=&gt; following : 终点over() 外的参数说明\t=&gt; LAG(col, n) : 往前第n行\t=&gt; LEAD(col, n) : 往后第n行123456789101112131415161718192021222324252627select name,count(*) over() from test1 where substring(orderdate, 1, 7) = &#x27;2017-04&#x27; group by name;// 会开两次窗，group by进行了去重&gt; 结果mart\t2jack\t2select name,count(*) over() from test1 where substring(orderdate, 1, 7) = &#x27;2017-04&#x27;;// 有几个name 就会开几个窗(5个)&gt; 结果mart\t5mart\t5mart\t5mart\t5jack\t5select orderdate,sum(cost) over(order by orderdate) from test1;// over() 中限制了窗口的大小，此时窗口的大小是根据 orderdate来判断，又因为 orderdate 进行了order by ，所以第一次开窗是最小的orderdate,逐步变大，sum() 中拿到的值也逐渐变多(窗口逐渐变大)，直到最后一个orderdate，窗口数据集就是整个数据集。select name, orderdate,cost,sum(cost) over(distribute by name) from test1;// distribute =&gt; 作用和group by 类似，可以起到分组去重的作用，over() 中不能使用 group byselect name, orderdate,cost,sum(cost) over(distribute by name sort by orderdate) from test1;select name, orderdate,cost,sum(cost) over(prtition by name order by orderdate) from test1;// sort by 和 order by 排序 order by 针对的是整体，sort by针对的是分组(分区)内的数据 distribute by 和 sort by 一般是连用， partition by 和 oreder by 连用select name,orderdate,cost,lag(orderdate, 1) over(partition by name order by orderdate) from test1;// lag(col, n) 是找到col类的前面第几行，针对上面的sql语句，每次找到的都是当前行的前面一行 lag() 会受到分区的阻挡，如果同时用到LAG() 和 LEAD() 需要在每个后面都跟上 over() ，因为over 只对它前面的一个聚合函数提供内容","tags":["hive"],"categories":["hive"]},{"title":"hive常用命令","path":"/2021/12/19/hive常用命令/","content":"Hive常用命令 常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546- 创建数据库create database name;- 创建数据库表( 需要先进入一个数据库 use name )create table name (id Int, name String) row format delimited FIELDS TERMINATED BY &#x27;分隔符&#x27;; - 导入数据 ( 加上 overwrite 就会将表清空后倒入，不加上就直接导入 )\t1. 从本地导入\tload data local inpath &#x27;数据地址&#x27; overwrite into table tableName;\t2. hdfs上导入\tload data inpath &#x27;数据地址&#x27; overwrite into tableName;\t- 查询\tgroup by 分组\torder by 排序 (desc倒序)\tgroup by 之后 where 要使用 having hive 中的不等于为 &lt;&gt;- 将查询的数据保存到其他位置 ( 加上 overwrite 就会将表清空后倒入，不加上就直接导入 )\t1. 保存到已存在的表中 insert overwrite table 保存数据的表 select * form 查询数据的表\t2. 保存到未存在的表中 create table 新表名(字段名，类型) as select * from 查询数据的表\t3. 保存到hdfs上 - hive 中字符串处理 博客地址( https://my.oschina.net/u/2441766/blog/1648467 ) length(字段名) 返回字段的长度 reverse(字段名) 返回反转之后的字段 concat(字段A，字段B) 返回字段A+字段B的字段 concat_ws(&quot;分隔号&quot;，字段A，字段B) 返回字段A+分隔号+字段B - hive 连接表 -join 1.left join 2.right join 3. - 建表 1. 建立普通表 create table tableName() row format delimited fields termanited by &#x27;,&#x27;; 2. 建立分区表 create table tableName() pratitionted by (分区字段 字段类型) row format delimited fields termanited by &#x27;,&#x27;; - 建立静态分区 alter table tableName add partition(分区字段=&quot;&quot;); - 删除分区 alter table tableName drop partition(分区字段=&quot;&quot;); - 删除表之前要将所有的分区都删除 如果你的分区中有中文字符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 修改Mysql中Hive表的编码格式alter database hive_meta default character set utf8;alter table BUCKETING_COLS default character set utf8;alter table CDS default character set utf8;alter table COLUMNS_V2 default character set utf8;alter table DATABASE_PARAMS default character set utf8;alter table DBS default character set utf8;alter table FUNCS default character set utf8;alter table FUNC_RU default character set utf8;alter table GLOBAL_PRIVS default character set utf8;alter table PARTITIONS default character set utf8;alter table PARTITION_KEYS default character set utf8;alter table PARTITION_KEY_VALS default character set utf8;alter table PARTITION_PARAMS default character set utf8;alter table ROLES default character set utf8;alter table SDS default character set utf8;alter table SD_PARAMS default character set utf8;alter table SEQUENCE_TABLE default character set utf8;alter table SERDES default character set utf8;alter table SERDE_PARAMS default character set utf8;alter table SKEWED_COL_NAMES default character set utf8;alter table SKEWED_COL_VALUE_LOC_MAP default character set utf8;alter table SKEWED_STRING_LIST default character set utf8;alter table SKEWED_STRING_LIST_VALUES default character set utf8;alter table SKEWED_VALUES default character set utf8;alter table SORT_COLS default character set utf8;alter table TABLE_PARAMS default character set utf8;alter table TAB_COL_STATS default character set utf8;alter table TBLS default character set utf8;alter table VERSION default character set utf8;alter table BUCKETING_COLS convert to character set utf8;alter table CDS convert to character set utf8;alter table COLUMNS_V2 convert to character set utf8;alter table DATABASE_PARAMS convert to character set utf8;alter table DBS convert to character set utf8;alter table FUNCS convert to character set utf8;alter table FUNC_RU convert to character set utf8;alter table GLOBAL_PRIVS convert to character set utf8;alter table PARTITIONS convert to character set utf8;alter table PARTITION_KEYS convert to character set utf8;alter table PARTITION_KEY_VALS convert to character set utf8;alter table PARTITION_PARAMS convert to character set utf8;alter table ROLES convert to character set utf8;alter table SDS convert to character set utf8;alter table SD_PARAMS convert to character set utf8;alter table SEQUENCE_TABLE convert to character set utf8;alter table SERDES convert to character set utf8;alter table SERDE_PARAMS convert to character set utf8;alter table SKEWED_COL_NAMES convert to character set utf8;alter table SKEWED_COL_VALUE_LOC_MAP convert to character set utf8;alter table SKEWED_STRING_LIST convert to character set utf8;alter table SKEWED_STRING_LIST_VALUES convert to character set utf8;alter table SKEWED_VALUES convert to character set utf8;alter table SORT_COLS convert to character set utf8;alter table TABLE_PARAMS convert to character set utf8;alter table TAB_COL_STATS convert to character set utf8;alter table TBLS convert to character set utf8;alter table VERSION convert to character set utf8;SET character_set_client = utf8 ;SET character_set_database = utf8 ;SET character_set_results = utf8 ;SET character_set_server = utf8 ;SET NAMES &#x27;utf8&#x27;;","tags":["hive"],"categories":["hive"]},{"title":"hive环境搭建","path":"/2021/11/12/hive环境搭建/","content":"Hive环境搭建 ( 配置Hive之前需要搭建好mysq ) 123# 环境变量export $HIVE_HOME=/opt/bigdata/hiveexport $PATH=$PATH:$HIVE_HOME/bin 123456789101112131415161718192021222324252627# hive-site.xml&lt;property&gt;\t&lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://localhost:3306/hive?createDatabaseIfnotExist=true&amp;amp;useSSL=false&lt;/value&gt;&lt;/property&gt;&lt;property&gt;\t&lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;&lt;/property&gt;&lt;property&gt;\t&lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;root&lt;/value&gt;&lt;/property&gt;&lt;property&gt;\t&lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;hadoop&lt;/value&gt;&lt;/property&gt;# 开启hive mateStore配置&lt;peoperty&gt;\t&lt;name&gt;hive.matestore.local&lt;/name&gt; &lt;value&gt;false&lt;/value&gt;&lt;/peoperty&gt;&lt;peoperty&gt;\t&lt;name&gt;hive.matestore.uris&lt;/name&gt; &lt;value&gt;thrift://hadoop01:9083&lt;/value&gt;&lt;/peoperty&gt; 123# hive-env.shexport HADOOP_HOME=/opt/bigdata/hadoopexport HIVE_CONF_HOME=/opt/bigdata/hive/conf 记得将mysql-connector-java的驱动移动到 $HIVE_HOME&#x2F;lib最后初始化 hive :\tschematool -dbType mysql -initSchema 启动Hive需要先启动hadoop集群 选配12345678910111213141516# Hive WebUI -- hive-site.xml中配置&lt;property&gt; &lt;name&gt;hive.server2.webui.host&lt;/name&gt; &lt;value&gt;localhost&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hive.server2.webui.port&lt;/name&gt; &lt;value&gt;10002&lt;/value&gt;&lt;/property&gt;# 查询时显示 标题内容&lt;property&gt; &lt;name&gt;hive.cli.print.header&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt; 可能出现的问题 org.apache.hadoop.hive.metastore.HiveMetaException: Failed to get schema version. 出现的原因： hive-site.xml 中的账号和密码错误 mysql 账号没有开启远程连接 mysql时区和系统自带的时区不同 java.lang.IncompatibleClassChangeError: Found class jline.Terminal, but interface was expected 出现的原因： hadoop下的jline jar包和hive 下的 jline jar包版本冲突( 不同 ) 解决方法： 将hive lib 下的 jline包复制覆盖掉hadoop - share - hadoop - yarn - lib 下的 jline 包","tags":["linux","hive"],"categories":["hive"]},{"path":"/about/index.html","content":"也许我们无法改变这个世界，但是我们可以改变自己的思想。本站是 @longxiaoyi 的个人站。关于友链本站 关于我的生命的前二十二年我之前的人生用碌碌无为来形容最不为过没有特别喜欢的事、没有特别喜欢的食物。感觉一切都能凑合着过，但时而会有点强迫症。一直和懒作斗争，但好像一直败在它手里。一直试图改变生活，却屡次被生活按在地上教我做事。但是我还是一个乐观、积极的、但又无趣的、平平淡淡、普普通通的十八线程序员。说起建立这个blog的原因 其一是希望告别从前的自己 其二是希望这个blog能够记录自己以后的生活，记录自己的成长 其三是希望等自己年龄稍微大点的时候有个怀念从前的地儿 本站没有任何推广和打赏链接，如果您觉得哪个作品不错，欢迎去对应的仓库点个赞，或者在对应的文章下面留言互动一下。"},{"path":"/fonts/font.css","content":"@font-face { font-family: 'LXGW WenKai'; src: url('./LXGWWenKaiScreen100.woff'); font-weight: normal; font-style: normal; } @font-face { font-family: 'LXGW WenKai'; src: url('./LXGWWenKaiScreen200.woff'); font-weight: normal; font-style: normal; } @font-face { font-family: 'LXGW WenKai'; src: url('./LXGWWenKaiScreen201.woff'); font-weight: normal; font-style: normal; } @font-face { font-family: 'LXGW WenKai'; src: url('./LXGWWenKaiScreen300.woff'); font-weight: normal; font-style: normal; }"},{"path":"/friend/index.html","content":"也许我们无法改变这个世界，但是我们可以改变自己的思想。本站是 @longxiaoyi 的个人站。关于友链本站"},{"path":"/timeline/index.html","content":"也许我们无法改变这个世界，但是我们可以改变自己的思想。本站是 @longxiaoyi 的个人站。关于友链本站 特别感谢xaoxuu 提供的 Stellar 主题，让我能顺利搭出本站点，由衷感谢。 关于本站2023 年 03 月 25 日域名审核成功2023 年 03 月 18 日添加评论功能2023 年 02 月 28 日数据迁移完成，注册新域名，等待域名审核中……2023 年 02 月 08 日创建文件夹，开始建立站点"}]